OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-11-22T11:55:03.628875-03:00' ],		#prior : OmReference [ 'Pharo8.0-SNAPSHOT-32bit-6b47e52.7vbxwux6oo8z4v5n1rasgw9o3', '2' ],		#self : OmReference [ '1' ]	},	#content : EpCategoryAddition {		#classCategoryName : #Games,		#affectedPackageName : #Games	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2024-11-22T11:55:03.632875-03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #DuelGameWithGUI\r\tinstanceVariableNames: \'board players currentPlayer winner window categories timer startTime feedbackWindow feedbackMorph\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'Games\'',				#superclassName : 'Object'			},			#name : #DuelGameWithGUI,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #board,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #players,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #currentPlayer,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #winner,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #window,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #categories,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #timer,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #startTime,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #feedbackWindow,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #DuelGameWithGUI,						#isMetaSide : false					},					#name : #feedbackMorph,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'DuelGameWithGUI class\r\tinstanceVariableNames: \'\''				},				#name : #'DuelGameWithGUI class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #DuelGameWithGUI,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #Games,			#package : #Games,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T11:57:03.865875-03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize [\r    "Inicializar el juego con un tablero y jugadores"\r    board := Array new: 5 withAll: [ Array new: 5 withAll: nil ].\r    players := { \'Jugador1\'. \'Jugador2\' }.\r    currentPlayer := players first.\r    winner := nil.\r]',			#stamp : 'Leonor 11/22/2024 11:57',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T11:57:03.878875-03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize [\r    "Inicializar el juego con un tablero y jugadores"\r    board := Array new: 5 withAll: [ Array new: 5 withAll: nil ].\r    players := { \'Jugador1\'. \'Jugador2\' }.\r    currentPlayer := players first.\r    winner := nil.\r]',			#stamp : 'Leonor 11/22/2024 11:57',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize [\r    "Inicializar el juego con un tablero y jugadores"\r    board := Array new: 5 withAll: [ Array new: 5 withAll: nil ].\r    players := { \'Jugador1\'. \'Jugador2\' }.\r    currentPlayer := players first.\r    winner := nil.\r]',			#stamp : 'Leonor 11/22/2024 11:57',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T11:57:59.039875-03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 11:57',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T11:58:54.069875-03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 11:57',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'/questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 11:58',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T11:59:14.334875-03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'/questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 11:58',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'\\questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 11:59',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:00:08.594875-03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'\\questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 11:59',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'C:\\Users\\leoro\\Documents\\Pharo\\images\\Moose Suite 8.0 (old stable)\\questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 12:00',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:03:04.185875-03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'C:\\Users\\leoro\\Documents\\Pharo\\images\\Moose Suite 8.0 (old stable)\\questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 12:00',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 12:03',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:04:27.525875-03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r    file := FileStream readOnlyFileNamed: \'questions.csv\'.\r    content := file contentsOfEntireFile.\r    lines := content lines.\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r    file close.\r]',			#stamp : 'Leonor 11/22/2024 12:03',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r\r    "Leer el archivo de preguntas"\r    file := FileSystem workingDirectory / \'questions.csv\'.\r    content := file readStream contents.\r    lines := content lines.\r\r    "Procesar cada línea del archivo"\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        \r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        \r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:04',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:09:52.124875-03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer |\r    categories := Dictionary new.\r\r    "Leer el archivo de preguntas"\r    file := FileSystem workingDirectory / \'questions.csv\'.\r    content := file readStream contents.\r    lines := content lines.\r\r    "Procesar cada línea del archivo"\r    lines do: [ :line |\r        | parts |\r        parts := line substrings: \',\'.\r        \r        category := parts first.\r        question := parts second.\r        answer := parts third.\r        \r        categories at: category ifAbsentPut: [ Dictionary new ].\r        (categories at: category) at: question put: answer.\r    ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:04',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #loadQuestionsFromFile,			#protocol : #'as yet unclassified',			#sourceCode : 'loadQuestionsFromFile [\r    | file content lines category question answer parts |\r    categories := Dictionary new.\r\r    "Leer el archivo de preguntas"\r    file := FileSystem workingDirectory / \'questions.csv\'.\r    content := file readStream contents.\r    lines := content lines.\r\r    "Procesar cada línea del archivo"\r    lines do: [ :line |\r        parts := line substrings: \',\'.\r\r        "Verificar que la línea tenga al menos 3 partes (categoría, pregunta, respuesta)"\r        (parts size >= 3) ifTrue: [\r            category := parts first.\r            question := parts second.\r            answer := parts third.\r\r            "Agregar la pregunta a la categoría correspondiente"\r            categories at: category ifAbsentPut: [ Dictionary new ].\r            (categories at: category) at: question put: answer.\r        ] ifFalse: [\r            Transcript show: \'Línea inválida: \', line; cr.\r        ].\r    ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:09',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:11:37.467875-03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'chooseQuestionFrom:',			#protocol : #'as yet unclassified',			#sourceCode : 'chooseQuestionFrom: category [\r    | questions question answer |\r    categories includesKey: category ifFalse: [\r        ^self error: \'La categoría \', category, \' no existe.\'.\r    ].\r\r    questions := categories at: category.\r    questions isEmpty ifTrue: [\r        ^self error: \'No hay preguntas disponibles para la categoría \', category, \'.\'.\r    ].\r\r    question := questions keys atRandom.\r    answer := questions at: question.\r    ^question -> answer.\r]\r',			#stamp : 'Leonor 11/22/2024 12:11',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:13:50.351875-03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'showFeedback:',			#protocol : #'as yet unclassified',			#sourceCode : 'showFeedback: message [\r    feedbackWindow := World newWindow: \'Resultado\' bounds: (0@0 corner: 500@200).\r    feedbackMorph := TextMorph new contents: message.\r    feedbackWindow addMorph: feedbackMorph.\r    feedbackWindow open.\r    timer stop.\r    feedbackMorph contents: message, \' Tiempo: \', (self getElapsedTime printOn: String new).\r]',			#stamp : 'Leonor 11/22/2024 12:13',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:14:16.759875-03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #startTimer,			#protocol : #'as yet unclassified',			#sourceCode : 'startTimer [\r    startTime := Time now.\r    timer := (Delay forSeconds: 1) repeat: [\r        | elapsedTime |\r        elapsedTime := (Time now - startTime) asSeconds.\r        feedbackMorph contents: \'Tiempo: \', elapsedTime printOn: String new.\r    ].\r    timer start.\r]',			#stamp : 'Leonor 11/22/2024 12:14',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:17:03.636875-03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'duelWithCategory:',			#protocol : #'as yet unclassified',			#sourceCode : 'duelWithCategory: category [\r    | questionAndAnswer question answer playerAnswer |\r    \r    "Seleccionamos una pregunta de la categoría"\r    questionAndAnswer := self chooseQuestionFrom: category.\r    question := questionAndAnswer key.\r    answer := questionAndAnswer value.\r\r    Transcript show: \'Pregunta: \', question; cr.\r    Transcript show: \'Respuesta esperada: \', answer; cr.\r\r    "Aquí puedes incluir lógica para preguntar al jugador y verificar la respuesta"\r    playerAnswer := UIManager default request: question.\r    (playerAnswer = answer)\r        ifTrue: [ Transcript show: \'¡Correcto!\'; cr. ]\r        ifFalse: [ Transcript show: \'¡Incorrecto! La respuesta era: \', answer; cr. ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:17',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:18:25.327875-03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'duelWithCategory:',		#newSelector : #'duelWith:',		#affectedClassName : 'DuelGameWithGUI>>#duelWithCategory:'	}}OmEntry {	#tags : {		#author : 'Leonor',		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ],		#time : DateAndTime [ '2024-11-22T12:18:25.345875-03:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'duelWith:',			#protocol : #'as yet unclassified',			#sourceCode : 'duelWith: category [\r    | questionAndAnswer question answer playerAnswer |\r    \r    "Seleccionamos una pregunta de la categoría"\r    questionAndAnswer := self chooseQuestionFrom: category.\r    question := questionAndAnswer key.\r    answer := questionAndAnswer value.\r\r    Transcript show: \'Pregunta: \', question; cr.\r    Transcript show: \'Respuesta esperada: \', answer; cr.\r\r    "Aquí puedes incluir lógica para preguntar al jugador y verificar la respuesta"\r    playerAnswer := UIManager default request: question.\r    (playerAnswer = answer)\r        ifTrue: [ Transcript show: \'¡Correcto!\'; cr. ]\r        ifFalse: [ Transcript show: \'¡Incorrecto! La respuesta era: \', answer; cr. ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:18',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2024-11-22T12:18:25.489875-03:00' ],		#trigger : OmReference [ '16' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'duelWithCategory:',			#protocol : #'as yet unclassified',			#sourceCode : 'duelWithCategory: category [\r    | questionAndAnswer question answer playerAnswer |\r    \r    "Seleccionamos una pregunta de la categoría"\r    questionAndAnswer := self chooseQuestionFrom: category.\r    question := questionAndAnswer key.\r    answer := questionAndAnswer value.\r\r    Transcript show: \'Pregunta: \', question; cr.\r    Transcript show: \'Respuesta esperada: \', answer; cr.\r\r    "Aquí puedes incluir lógica para preguntar al jugador y verificar la respuesta"\r    playerAnswer := UIManager default request: question.\r    (playerAnswer = answer)\r        ifTrue: [ Transcript show: \'¡Correcto!\'; cr. ]\r        ifFalse: [ Transcript show: \'¡Incorrecto! La respuesta era: \', answer; cr. ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:17',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:20:35.674875-03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'duelWith:at:player2:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'duelWith: player1 at: pos1 player2: player2 at: pos2 [\r    | category questionAndAnswer question answer questionWindow |\r    \r    "Seleccionamos una categoría aleatoria"\r    category := self chooseCategory atRandom.\r    \r    "Obtenemos la pregunta y respuesta como una asociación"\r    questionAndAnswer := self chooseQuestionFrom: category.\r    question := questionAndAnswer key. "La clave es la pregunta"\r    answer := questionAndAnswer value. "El valor es la respuesta"\r    \r    "Creamos una ventana para mostrar la pregunta"\r    questionWindow := World newWindow: \'Pregunta de \', category bounds: (0@0 corner: 500@200).\r    questionWindow addMorph: (TextMorph new contents: question).\r]\r',			#stamp : 'Leonor 11/22/2024 12:20',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:22:51.211875-03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'conquerCell:at:y:',			#protocol : #'as yet unclassified',			#sourceCode : 'conquerCell: player at: x y: y [\r    (board at: x at: y) ifNil: [  "Si la casilla está vacía"\r        board at: x at: y put: player.  "Coloca al jugador en esa casilla"\r        self printBoard. "Muestra el estado del tablero"\r    ] ifNotNil: [ "Si la casilla ya está ocupada"\r        \'Esta casilla ya está ocupada\' displayNl.\r    ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:22',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:23:16.076875-03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #checkWinner,			#protocol : #'as yet unclassified',			#sourceCode : 'checkWinner [\r    board do: [ :row |\r        row do: [ :cell |\r            cell = nil ifTrue: [ ^self ].\r        ].\r    ].\r    winner := currentPlayer.\r    \'¡El ganador es \', winner, \'!\' displayNl.\r    ^self.\r]',			#stamp : 'Leonor 11/22/2024 12:23',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:23:42.565875-03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #startGame,			#protocol : #'as yet unclassified',			#sourceCode : 'startGame [\r    self initialize.\r    self loadQuestionsFromFile.\r    self startTimer.\r    self printBoard.\r]',			#stamp : 'Leonor 11/22/2024 12:23',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:24:04.722875-03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #getElapsedTime,			#protocol : #'as yet unclassified',			#sourceCode : 'getElapsedTime [\r    ^(Time now - startTime) asSeconds.\r]',			#stamp : 'Leonor 11/22/2024 12:24',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:29:25.941875-03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #checkWinner,			#protocol : #'as yet unclassified',			#sourceCode : 'checkWinner [\r    board do: [ :row |\r        row do: [ :cell |\r            cell = nil ifTrue: [ ^self ].\r        ].\r    ].\r    winner := currentPlayer.\r    \'¡El ganador es \', winner, \'!\' displayNl.\r    ^self.\r]',			#stamp : 'Leonor 11/22/2024 12:23',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #checkWinner,			#protocol : #'as yet unclassified',			#sourceCode : 'checkWinner [\r\tTranscript show: \'metodocheckwinner\'.\r    board do: [ :row |\r        row do: [ :cell |\r            cell = nil ifTrue: [ ^self ].\r        ].\r    ].\r    winner := currentPlayer.\r    \'¡El ganador es \', winner, \'!\' displayNl.\r    ^self.\r]',			#stamp : 'Leonor 11/22/2024 12:29',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:30:09.902875-03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'chooseQuestionFrom:',			#protocol : #'as yet unclassified',			#sourceCode : 'chooseQuestionFrom: category [\r    | questions question answer |\r    categories includesKey: category ifFalse: [\r        ^self error: \'La categoría \', category, \' no existe.\'.\r    ].\r\r    questions := categories at: category.\r    questions isEmpty ifTrue: [\r        ^self error: \'No hay preguntas disponibles para la categoría \', category, \'.\'.\r    ].\r\r    question := questions keys atRandom.\r    answer := questions at: question.\r    ^question -> answer.\r]\r',			#stamp : 'Leonor 11/22/2024 12:11',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'chooseQuestionFrom:',			#protocol : #'as yet unclassified',			#sourceCode : 'chooseQuestionFrom: category [\r    | questions question answer |\r\tTranscript show: \'metodocheckwinner\'.\r    categories includesKey: category ifFalse: [\r        ^self error: \'La categoría \', category, \' no existe.\'.\r    ].\r\r    questions := categories at: category.\r    questions isEmpty ifTrue: [\r        ^self error: \'No hay preguntas disponibles para la categoría \', category, \'.\'.\r    ].\r\r    question := questions keys atRandom.\r    answer := questions at: question.\r    ^question -> answer.\r]\r',			#stamp : 'Leonor 11/22/2024 12:30',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T12:30:19.700875-03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'chooseQuestionFrom:',			#protocol : #'as yet unclassified',			#sourceCode : 'chooseQuestionFrom: category [\r    | questions question answer |\r\tTranscript show: \'metodocheckwinner\'.\r    categories includesKey: category ifFalse: [\r        ^self error: \'La categoría \', category, \' no existe.\'.\r    ].\r\r    questions := categories at: category.\r    questions isEmpty ifTrue: [\r        ^self error: \'No hay preguntas disponibles para la categoría \', category, \'.\'.\r    ].\r\r    question := questions keys atRandom.\r    answer := questions at: question.\r    ^question -> answer.\r]\r',			#stamp : 'Leonor 11/22/2024 12:30',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'chooseQuestionFrom:',			#protocol : #'as yet unclassified',			#sourceCode : 'chooseQuestionFrom: category [\r    | questions question answer |\r\tTranscript show: \'metodocategory\'.\r    categories includesKey: category ifFalse: [\r        ^self error: \'La categoría \', category, \' no existe.\'.\r    ].\r\r    questions := categories at: category.\r    questions isEmpty ifTrue: [\r        ^self error: \'No hay preguntas disponibles para la categoría \', category, \'.\'.\r    ].\r\r    question := questions keys atRandom.\r    answer := questions at: question.\r    ^question -> answer.\r]\r',			#stamp : 'Leonor 11/22/2024 12:30',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T13:05:38.863875-03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #printBoard,			#protocol : #'as yet unclassified',			#sourceCode : 'printBoard [\r    | boardText |\r    boardText := String new.\r    board do: [ :row |\r        row do: [ :cell |\r            boardText := boardText , (cell isNil ifTrue: [ \'-\' ] ifFalse: [ cell ]) , \' \'.\r        ].\r        boardText := boardText , String cr.\r    ].\r    \'Tablero: \', boardText displayNl.\r]\r',			#stamp : 'Leonor 11/22/2024 13:05',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T13:05:38.873875-03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #printBoard,			#protocol : #'as yet unclassified',			#sourceCode : 'printBoard [\r    | boardText |\r    boardText := String new.\r    board do: [ :row |\r        row do: [ :cell |\r            boardText := boardText , (cell isNil ifTrue: [ \'-\' ] ifFalse: [ cell ]) , \' \'.\r        ].\r        boardText := boardText , String cr.\r    ].\r    \'Tablero: \', boardText displayNl.\r]\r',			#stamp : 'Leonor 11/22/2024 13:05',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #printBoard,			#protocol : #printing,			#sourceCode : 'printBoard [\r    | boardText |\r    boardText := String new.\r    board do: [ :row |\r        row do: [ :cell |\r            boardText := boardText , (cell isNil ifTrue: [ \'-\' ] ifFalse: [ cell ]) , \' \'.\r        ].\r        boardText := boardText , String cr.\r    ].\r    \'Tablero: \', boardText displayNl.\r]\r',			#stamp : 'Leonor 11/22/2024 13:05',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T13:07:01.583875-03:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #startGame,			#protocol : #'as yet unclassified',			#sourceCode : 'startGame [\r    self initialize.\r    self loadQuestionsFromFile.\r    self startTimer.\r    self printBoard.\r]',			#stamp : 'Leonor 11/22/2024 12:23',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #startGame,			#protocol : #'as yet unclassified',			#sourceCode : 'startGame [\r    "Cargar las preguntas solo una vez"\r    self loadQuestionsFromFile.\r    \'Preguntas cargadas\' displayNl.\r\r    "Iniciar el temporizador"\r    self startTimer.\r    \'Temporizador iniciado\' displayNl.\r\r    self printBoard.\r    \'Tablero impreso\' displayNl.\r]\r',			#stamp : 'Leonor 11/22/2024 13:07',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T13:09:38.661875-03:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #startTimer,			#protocol : #'as yet unclassified',			#sourceCode : 'startTimer [\r    startTime := Time now.\r    timer := (Delay forSeconds: 1) repeat: [\r        | elapsedTime |\r        elapsedTime := (Time now - startTime) asSeconds.\r        feedbackMorph contents: \'Tiempo: \', elapsedTime printOn: String new.\r    ].\r    timer start.\r]',			#stamp : 'Leonor 11/22/2024 12:14',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #startTimer,			#protocol : #'as yet unclassified',			#sourceCode : 'startTimer [\r    startTime := Time now.\r    timer := (Delay forSeconds: 1) repeat: [\r        | elapsedTime |\r        elapsedTime := (Time now - startTime) asSeconds.\r        feedbackMorph contents: \'Tiempo: \', (elapsedTime printOn: String new) asString.\r    ].\r    timer start.\r]\r',			#stamp : 'Leonor 11/22/2024 13:09',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T13:21:04.240875-03:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'conquerCell:at:y:',			#protocol : #'as yet unclassified',			#sourceCode : 'conquerCell: player at: x y: y [\r    (board at: x at: y) ifNil: [  "Si la casilla está vacía"\r        board at: x at: y put: player.  "Coloca al jugador en esa casilla"\r        self printBoard. "Muestra el estado del tablero"\r    ] ifNotNil: [ "Si la casilla ya está ocupada"\r        \'Esta casilla ya está ocupada\' displayNl.\r    ].\r]\r',			#stamp : 'Leonor 11/22/2024 12:22',			#package : #Games		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #DuelGameWithGUI,				#isMetaSide : false			},			#name : #'conquerCell:at:y:',			#protocol : #'as yet unclassified',			#sourceCode : 'conquerCell: player at: x y: y [\r    (board at: x at: y) ifNil: [  "Si la casilla está vacía"\r        board at: x at: y put: player.  "Coloca al jugador en esa casilla"\r        self printBoard. "Muestra el estado del tablero"\r    ] ifNotNil: [ "Si la casilla ya está ocupada"\r        \'Esta casilla ya está ocupada\' displayNl.\r    ].\r]\r\tTranscript show: \'metodocheckwinner\'.',			#stamp : 'Leonor 11/22/2024 13:21',			#package : #Games		}	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T13:21:27.114875-03:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\leoro\\Documents\\Pharo\\images\\Moose Suite 8.0 (old stable)\\Moose Suite 8.0 (old stable).image'	}}OmEntry {	#tags : {		#author : 'Leonor',		#time : DateAndTime [ '2024-11-22T13:21:36.921875-03:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpSessionSnapshot {		#imageName : 'C:\\Users\\leoro\\Documents\\Pharo\\images\\Moose Suite 8.0 (old stable)\\Moose Suite 8.0 (old stable).image'	}}