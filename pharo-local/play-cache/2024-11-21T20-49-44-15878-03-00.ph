Object subclass: DuelGame [        | board players currentPlayer winner categories startTime |    "Inicializar el juego con un tablero y jugadores"    DuelGame class >> newGame [        ^self new initialize    ]    initialize [        board := Array new: 5.        board := board collect: [ Array new: 5 withAll: nil ].        players := { 'Jugador1'. 'Jugador2' }.        currentPlayer := players first.        winner := nil.        categories := Dictionary new.    ]    loadQuestionsFromFile [        | file content lines category question answer |                "Abrir el archivo de preguntas"        file := FileStream readOnlyFileNamed: 'questions.csv'.        content := file contentsOfEntireFile.        file close.        lines := content lines.        lines do: [ :line |            | parts |            parts := line substrings: ','.            category := parts first.            question := parts second.            answer := parts third.                        (categories at: category ifAbsentPut: [ Dictionary new ]) at: question put: answer.        ].    ]    chooseCategory [        ^categories keys atRandom    ]    chooseQuestionFrom: category [        | questions question answer |        questions := categories at: category ifAbsent: [ ^nil ].        question := questions keys atRandom.        answer := questions at: question.        ^question -> answer    ]    playTurn [        | category question answer playerAnswer |        "Seleccionar categoría y pregunta"        category := self chooseCategory.        question -> answer := self chooseQuestionFrom: category.        Transcript show: 'Turno de: ', currentPlayer; cr.        Transcript show: 'Categoría: ', category; cr.        Transcript show: 'Pregunta: ', question; cr.        "Simulamos la respuesta del jugador"        playerAnswer := (self simulatePlayerResponse: currentPlayer for: answer).                "Evaluar respuesta"        playerAnswer = answer            ifTrue: [                 Transcript show: '¡Correcto!'; cr.                self conquerRandomCell.            ]            ifFalse: [                 Transcript show: '¡Incorrecto! La respuesta correcta era: ', answer; cr.            ].        self checkWinner.        self switchPlayer.    ]    simulatePlayerResponse: player for: answer [        "Simula la respuesta del jugador (siempre correcta para probar)"        ^answer    ]    conquerRandomCell [        | x y |        x := (1 to: 5) atRandom.        y := (1 to: 5) atRandom.        (board at: x) at: y ifNil: [             (board at: x) at: y put: currentPlayer.            Transcript show: 'Casilla conquistada en: (', x printString, ',', y printString, ') por: ', currentPlayer; cr.        ] ifNotNil: [             Transcript show: 'La casilla (', x printString, ',', y printString, ') ya está ocupada'; cr.        ].    ]    checkWinner [        board do: [ :row |            row do: [ :cell |                cell ifNil: [ ^self ]. "El juego continúa mientras haya casillas vacías"            ].        ].        winner := currentPlayer.        Transcript show: '¡El ganador es: ', winner, '!'; cr.        ^self.    ]    switchPlayer [        currentPlayer := (currentPlayer = players first) ifTrue: [ players second ] ifFalse: [ players first ].    ]    startGame [        "Cargar las preguntas"        self loadQuestionsFromFile.        "Jugar turnos hasta que haya un ganador"        [ winner isNil ] whileTrue: [ self playTurn ].    ]]